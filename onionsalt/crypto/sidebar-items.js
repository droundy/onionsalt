initSidebarItems({"enum":[["NaClError","The error return type.  You can get errors for only one of three reasons:"]],"fn":[["box_afternm","Encrypt a message after creating a secret key using `box_beforenm`.  The two functions together come out to the same thing as `box_up`."],["box_beforenm","Prepare to either open or encrypt some public-key messages. This is useful if you want to handle many messages between the same two recipients, since it allows you to do the public-key business just once."],["box_keypair","Generate a random public/secret key pair.  This is the *only* way you should generate keys.  Although of course you can store keys to disk and then read them back again.  But they always start with `box_keypair`."],["box_open","Open a message encrypted with `crypto::box_up`."],["box_open_afternm","Decrypt a message using a key that was precomputed using `box_beforenm`.  The two functions together are the same as the easier-to-use `box_open`."],["box_up","An implementation of the NaCl function `crypto_box`, renamed to `crypto::box_up` because `box` is a keyword in rust."],["funnybox_open","Decrypt a message encrypted with `funnybox`, only authenticating the first `nauth` bytes."],["hash","Compute the SHA512 hash of some data."],["random_24","Securely creates 32 random bytes."],["random_32","Securely creates 32 random bytes."],["random_byte","Securely creates a byte."],["random_nonce","Securely creates a random nonce.  This function isn't in the NaCl, but I feel like it could be very handy, and a random nonce from a secure source is often what you want."],["random_u32","Securely creates a u32."],["random_u64","Securely creates a u64."],["secretbox","Use symmetric encryption to encrypt a message."],["secretbox_open","Decrypt a message encrypted with `secretbox`."],["sillybox","An implementation of public-key encryption similar to the NaCl function `crypto_box` (renamed `crypto::sillybox_up` in this package), but with the feature that it only authenticates the first `nauth` bytes.  This is not useful for most purposes (thus its silly name), but is helpful for enabling round-trip onion routing in which all the routing information is authenticated (to information leaks triggered by maliciously modified packets), but information may be added to the communication en-route."],["sillybox_afternm","Encrypt a message after creating a secret key using `sillybox_beforenm`.  The two functions together come out to the same thing as `sillybox`, which you should read to find out how it differs from the standard NaCl `box` encryption."],["sillybox_beforenm","Prepare to either open or encrypt some public-key messages. This is useful if you want to handle many messages between the same two recipients, since it allows you to do the public-key business just once."],["sillybox_open","Open a message encrypted with `crypto::sillybox_up`, only authenticating the first `nauth` bytes.  It is your business to separately verify (or distrust) the remaining bytes.  An obvious approach would be to nest in the remaining bytes an encrypted and authenticated message."],["sillybox_open_afternm","Decrypt a message using a key that was precomputed using `sillybox_beforenm`.  The two functions together are the same as the easier-to-use `sillybox_open`."]],"struct":[["KeyPair","A pair with public and secret keys."],["Nonce","A nonce.  You should never reuse a nonce for two different messages between the same set of keys."],["PublicKey","A public key."],["SecretKey","A secret key."]]});